Dynamic programming is both a mathematical optimization method and a computer programming method. The method was developed by Richard Bellman in the 1950s and has found applications in numerous fields,
from aerospace engineering to economics.If sub-problems can be nested recursively inside larger problems, so that dynamic programming methods are applicable, then there is a relation between the value 
of the larger problem and the values of the sub-problems.

First Question :: Rod Cutting

#include <bits/stdc++.h>
using namespace std;

int cutRod(int price[], int i, int n,vector<vector<int> >& dp){
	// base case
	if (i <= 0) {
		return n * price[0];
	}
	if (dp[i][n] != -1)
		return dp[i][n];

	int remCut = cutRod(price, i - 1, n,dp);
	int cut = INT_MIN;
	int rod_length = i + 1;

	if (rod_length <= n)
		cut = price[i]+ cutRod(price, i, n - rod_length,dp);

	return dp[i][n]=max(remCut, cut);
	
}
int main()
{
    int n;
    cin>>n;
    int arr[n];
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    // int size = sizeof(arr) / sizeof(arr[0]);
	vector<vector<int> > dp(n,vector<int>(n + 1, -1));
    cout<<cutRod(arr,n-1,n,dp);
}

// Time Complexity: O(n^2)

// Space Complexity: O(n^2)+O(n)

Question 2 : Longest Common Subsequence

// uploading popular questions of dynamic programming

#include<bits/stdc++.h>
typedef long long int ll;
using namespace std;
int dp[105][105];

int longest_commom_subsequence(int i,int j,string s1,string s2){
    if(i<=0||j<=0){                                  // Base condition
        return 0;
    }
    if(dp[i][j]!=-1){                               // if already solved the case directly return the solution
        return dp[i][j];
    }

    int ans=0;

    ans = max(ans,longest_commom_subsequence(i-1,j,s1,s2));                
    ans = max(ans,longest_commom_subsequence(i,j-1,s1,s2));
    ans = max(ans,longest_commom_subsequence(i-1,j-1,s1,s2)+ (s1[i-1]==s2[j-1])) ;

    return dp[i][j]=ans;

}
int main(){
    memset(dp,-1,sizeof(dp));                    // initializing dp value by -1
    int t;
    cin>>t;
    while(t--){
        string test_case1,test_case2;
        cin>>test_case1>>test_case2;

        cout<<longest_commom_subsequence(test_case1.length(),test_case2.length(),test_case1,test_case2);
    }
}

// Time complexity : O(n*m)
// n and m are length of strings

Question 3 : 0-1 knapsack

#include <bits/stdc++.h>
using namespace std;
int knapSackRec(int W, int wt[],int val[], int i,int** dp){
	// base condition
	if (i < 0)
		return 0;
	if (dp[i][W] != -1)
		return dp[i][W];

	if (wt[i] > W) {
		dp[i][W] = knapSackRec(W, wt,
							val, i - 1,
							dp);
		return dp[i][W];
	}
	else {
		dp[i][W] = max(val[i]
					+ knapSackRec(W - wt[i],
								wt, val,
								i - 1, dp),
					knapSackRec(W, wt, val,
								i - 1, dp));
		return dp[i][W];
	}
}

int knapSack(int W, int wt[], int val[], int n)
{
	int** dp;
	dp = new int*[n];
	for (int i = 0; i < n; i++)
		dp[i] = new int[W + 1];
	for (int i = 0; i < n; i++)
		for (int j = 0; j < W + 1; j++)
			dp[i][j] = -1;
	return knapSackRec(W, wt, val, n - 1, dp);
}
int main()
{
	int val[] = { 60, 100, 120 };
	int wt[] = { 10, 20, 30 };
  int n;
  cin>>n;
  int val[n];
  int wt[n];
	int W = 50;
  for(int i=0;i<n;i++){
      cin>>val[i]>>wt[i];
      }
	cout << knapSack(W, wt, val, n);
}

// I will continue other popular codes of dynamic programming also.
